{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Node System Documentation","text":""},{"location":"#overview","title":"Overview","text":"<p>The Node System is a DEPIN (Decentralized Physical Infrastructure Network) enabling decentralized workload execution, performance tracking, and reward distribution.</p>"},{"location":"#stakeholders","title":"Stakeholders","text":"<ol> <li>Users: Operate nodes by purchasing NFTs.</li> <li>Project Owners: Define workloads and distribute rewards.</li> <li>Node Operators: Manage Node CLI and Dashboard.</li> </ol>"},{"location":"#architecture","title":"Architecture","text":"<p>There are several components in the Node System architecture:</p> <ul> <li>Node CLI: Command-line interface for managing a node and its workloads.</li> <li>Workload Manager: Version control and uptime management for workloads.</li> <li>Node System Backend: Backend API for managing nodes/workloads, uptime tracking and notification</li> <li>Workload Master: Hosted by project owners, responsible for defining workloads and distributing rewards.</li> </ul> <p>Each component has its own respository, to run them locally, please refer to each component's documentation.</p> <p>This is a high-level overview of the Node System architecture:</p> <p></p>"},{"location":"#node-system-workflow","title":"Node System Workflow","text":"<p>After purchasing NFTs from project owners, users can operate workloads using the Node CLI. Each NFT serves as a license for running a specific workload.</p> <p>Users utilize the Node CLI to initialize a K3S cluster on their machines and deploy workloads. Workloads, defined by project owners, run within the K3S cluster. A special hidden workload, called workload manager is responsible for the following tasks:</p> <ul> <li>Receiving health checks from workloads and sending their status to the backend every minute.</li> <li>Periodically verifying workload versions and automatically updating them as needed.</li> <li>Performing self-updates to ensure it remains up-to-date.</li> </ul> <p>Workloads fetch tasks from project owners, execute them, and report the results back to the respective project owners. </p> <p>At the end of each day, project owners calculate points based on workload uptime and task execution results. These points are then committed to the backend as the final performance metrics.</p> <p>This is an overview of the Node System workflow:</p> <pre><code>sequenceDiagram\n    participant Node\n    participant Workload\n    participant PO as Project Owner\n    participant Backend as Node System Backend\n\n    Node-&gt;&gt;Workload: Start Workload using CLI\n\n    loop\n        Workload-&gt;&gt;PO: Request tasks\n        PO--&gt;&gt;Workload: Send tasks\n        Workload-&gt;Workload: Execute tasks\n        Workload-&gt;PO: Report task results\n    end\n\n    loop Every minute\n        Workload-&gt;&gt;Backend: Report health status\n    end\n\n    loop Every day\n        PO-&gt;&gt;Backend: Fetch Uptime Data\n        Backend--&gt;&gt;PO: Return workload uptime Data\n        PO-&gt;&gt;PO: Calculate Points\n        PO-&gt;&gt;Backend: Commit final points of Workload\n    end</code></pre>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Decentralized Infrastructure: Distributed workload execution.</li> <li>NFT Licensing: Simplifies node ownership.</li> <li>Automated Rewards: Transparent reward distribution.</li> <li>Performance Tracking: Tracks uptime and workload results.</li> </ul>"},{"location":"#additional-resources","title":"Additional Resources","text":"<ul> <li>What is a Node</li> <li>Node System Articles</li> </ul>"},{"location":"backend/","title":"Node System Backend (BE)","text":"<p>This repository contains the backend system for the Node System project, built using NestJS, Redis, and PostgreSQL. It provides APIs and services for managing nodes, projects, and workloads, with features like uptime tracking, notifications, and data persistence.</p>"},{"location":"backend/#prerequisites","title":"Prerequisites","text":"<ul> <li>Node.js (v22 or higher)</li> <li>Docker and Docker Compose</li> <li>PostgreSQL and Redis (if not using Docker)</li> </ul>"},{"location":"backend/#how-to-run","title":"How to run","text":"<ol> <li>Run services using Docker Compose (Optional)    <pre><code>docker-compose up -d\n</code></pre>    This will start PostgreSQL and Redis in the background.</li> <li>Install dependencies:    <pre><code>pnpm install\n</code></pre></li> <li>Copy the configuration file:    <pre><code>cp config.example.yaml config.yaml\n</code></pre></li> <li>Update the <code>config.yaml</code> file with your own settings.</li> <li>Run the application:    <pre><code>pnpm dev\n</code></pre></li> </ol>"},{"location":"backend/#folder-structure","title":"Folder Structure","text":"<pre><code>\u251c\u2500\u2500 prisma\n\u2502   \u251c\u2500\u2500 schema          # Contains the Prisma schema file for defining the database structure.\n\u2502   \u2514\u2500\u2500 seed.ts         # Script for seeding the database with initial data.\n\u251c\u2500\u2500 src\n\u2502   \u251c\u2500\u2500 api\n\u2502   \u2502   \u251c\u2500\u2500 v1          # Version 1 of the API, organized by feature modules.\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 inventory      # API endpoints for managing inventory.\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 node           # API endpoints for managing nodes.\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 notification   # API endpoints for sending notifications.\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 project        # API endpoints for managing projects.\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 user           # API endpoints for user management.\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 workload       # API endpoints for managing workloads.\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 index.ts       # Entry point for the v1 API module.\n\u2502   \u2502   \u251c\u2500\u2500 api.module.ts      # Module definition for the API layer.\n\u2502   \u2502   \u251c\u2500\u2500 api.service.ts     # Service layer for handling API logic.\n\u2502   \u2502   \u2514\u2500\u2500 index.ts           # Entry point for the API directory.\n\u2502   \u251c\u2500\u2500 app\n\u2502   \u2502   # Core application module, typically includes the main application logic.\n\u2502   \u251c\u2500\u2500 common\n\u2502   \u2502   \u251c\u2500\u2500 decorators         # Custom decorators for enhancing functionality.\n\u2502   \u2502   \u251c\u2500\u2500 exceptions         # Custom exception handling logic.\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 client         # Client-side exceptions.\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 filters        # Exception filters for handling errors.\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 server         # Server-side exceptions.\n\u2502   \u2502   \u251c\u2500\u2500 guards             # Authorization and authentication guards.\n\u2502   \u2502   \u251c\u2500\u2500 helper             # Utility functions and helpers.\n\u2502   \u2502   \u2514\u2500\u2500 interceptors       # Interceptors for modifying request/response behavior.\n\u2502   \u251c\u2500\u2500 configs\n\u2502   \u2502   # Configuration files for the application (e.g., environment settings).\n\u2502   \u251c\u2500\u2500 modules\n\u2502   \u2502   \u251c\u2500\u2500 cron               # Cron job scheduling and management.\n\u2502   \u2502   \u251c\u2500\u2500 mail               # Email service module.\n\u2502   \u2502   \u251c\u2500\u2500 pg                 # Direct access PostgreSQL database module.\n\u2502   \u2502   \u251c\u2500\u2500 prisma             # Prisma ORM integration module.\n\u2502   \u2502   \u251c\u2500\u2500 redis              # Redis caching and data store module.\n\u2502   \u2502   \u2514\u2500\u2500 uptime             # Uptime monitoring module.\n\u2502   \u251c\u2500\u2500 third-party\n\u2502   \u2502   \u251c\u2500\u2500 datagram           # Integration with Datagram services.\n\u2502   \u2502   \u2514\u2500\u2500 thegraph           # Integration with The Graph protocol.\n\u2502   \u2514\u2500\u2500 main.ts                # Entry point for the application.\n\u251c\u2500\u2500 &lt;configuration files&gt; ...\n\u251c\u2500\u2500 README.md\n\u2514\u2500\u2500 tsconfig.json\n</code></pre> <p>Node System Backend is built from NestJS, responsible for:</p> <ul> <li>Node and workload management</li> <li>Uptime tracking</li> <li>Notification when node/workload is down</li> <li>Save user reward points</li> </ul>"},{"location":"backend/#architecture","title":"Architecture","text":"<p>The Node System Backend is simple as below:</p> <pre><code>graph TD\n    A[NestJS Backend]\n    G[Subgraph]\n    P[(PostgreSQL)]\n    R[Redis]\n\n    A --&gt;|Query| G\n    A --&gt;|Prisma ORM| P\n    A --&gt;|Cache Layer| R\n\n    subgraph External Services\n        G\n    end\n\n    subgraph Data Layer\n        P\n        R\n    end</code></pre> <p>It consists of:</p> <ul> <li>NestJS Backend: The main application that handles API requests/responses and cron jobs.</li> <li>PostgreSQL: The database used for storing node, worqkload, uptime and reward information.</li> <li>Redis: The cache layer used for storing node/workload status.</li> <li>Subgraph: For fetching NFT data, user balances.</li> </ul>"},{"location":"backend/#datagram-integration","title":"Datagram integration","text":"<p>If project owners do not have their own reward distribution system, they can leverage the Datagram. Datagram is the DePIN baselayer \u2014 an AI-driven, Hyper-Fabric Network enabling fast, scalable connectivity and DePIN interoperability.</p> <p>The entire system architecture integration with Datagram is as below:</p> <p></p> <p>Each workload now has a Datagram substrate distributed together with its main components. Uptime tracking and reward distribution will be handled by the Datagram network instead of the Node System Backend.</p>"},{"location":"node-cli/","title":"Node CLI","text":"<p><code>lfgnode</code> is a command-line interface (CLI) tool for managing workloads and clusters in the LFG network. This document provides an overview of the commands, folder structure, and CI/CD pipeline used in this repository.</p>"},{"location":"node-cli/#prerequisites","title":"Prerequisites","text":"<ul> <li>For MacOS &amp; Windows, Docker Desktop is required.</li> <li>After installing Docker Desktop. Open Docker Desktop -&gt; Setting -&gt; General -&gt; Select <code>Use WSL 2 Based Engine</code> -&gt; Select <code>dd the *.docker.internal names to the host's /etc/hosts file</code> -&gt; Apply &amp; Restart.</li> <li>For Linux, Docker Engine is required.</li> <li>Go 1.23 or later is required to build the CLI from source.</li> </ul>"},{"location":"node-cli/#how-to-run","title":"How to run","text":"<ol> <li>Download packages    <pre><code>go get\ngo mod tidy\n</code></pre></li> <li>Build the CLI    <pre><code>go build -o lfgnode main.go\n</code></pre></li> </ol>"},{"location":"node-cli/#commands","title":"Commands","text":"<p>The <code>lfgnode</code> CLI supports the following commands:</p>"},{"location":"node-cli/#core-commands","title":"Core Commands","text":"<ul> <li><code>start</code>: Start the LFG cluster.</li> <li><code>stop</code>: Stop the LFG cluster.</li> <li><code>status</code>: Check the status of the LFG cluster.</li> <li><code>update</code>: Update the CLI or cluster components.</li> <li><code>info</code>: Display information about the node.</li> <li><code>version</code>: Print the version of the CLI.</li> <li><code>config</code>: Manage configuration settings.</li> </ul>"},{"location":"node-cli/#workload-management","title":"Workload Management","text":"<ul> <li><code>workload add</code>: Add a new workload to the cluster.</li> <li><code>workload list</code>: List all workloads in the cluster.</li> <li><code>workload remove</code>: Remove a workload from the cluster.</li> <li><code>workload restart</code>: Restart a workload.</li> <li><code>workload status</code>: Check the status of a workload.</li> </ul>"},{"location":"node-cli/#folder-structure","title":"Folder Structure","text":"<p>The repository is organized as follows:</p> <pre><code>.\n\u251c\u2500\u2500 cmd/                # CLI commands\n\u2502   \u251c\u2500\u2500 cmd.go          # Root command definition\n\u2502   \u251c\u2500\u2500 start.go        # Start command\n\u2502   \u251c\u2500\u2500 stop.go         # Stop command\n\u2502   \u251c\u2500\u2500 update.go       # Update command\n\u2502   \u251c\u2500\u2500 workload/       # Workload-related commands\n\u2502   \u2502   \u251c\u2500\u2500 add.go\n\u2502   \u2502   \u251c\u2500\u2500 list.go\n\u2502   \u2502   \u251c\u2500\u2500 remove.go\n\u2502   \u2502   \u2514\u2500\u2500 status.go\n\u2502   \u2514\u2500\u2500 config/         # Configuration-related commands\n\u2502       \u251c\u2500\u2500 config.go\n\u2502       \u2514\u2500\u2500 privateKey.go\n\u251c\u2500\u2500 internal/           # Internal logic and utilities\n\u2502   \u251c\u2500\u2500 api/            # API integrations\n\u2502   \u251c\u2500\u2500 cluster/        # Cluster management (e.g., k3d)\n\u2502   \u251c\u2500\u2500 hooks/          # Pre-run hooks for commands\n\u2502   \u2514\u2500\u2500 workload/       # Workload management logic\n\u251c\u2500\u2500 pkg/                # Shared packages\n\u2502   \u251c\u2500\u2500 config/         # Configuration utilities\n\u2502   \u251c\u2500\u2500 logger/         # Logging utilities\n\u2502   \u251c\u2500\u2500 constants/      # Constants used across the project\n\u2502   \u2514\u2500\u2500 util/           # Helper functions\n\u251c\u2500\u2500 scripts/            # Shell scripts for installation and setup\n\u2502   \u251c\u2500\u2500 install.sh      # Linux installation script\n\u2502   \u2514\u2500\u2500 install_macos.sh # MacOS installation script\n\u251c\u2500\u2500 docs/               # Documentation\n\u2502   \u2514\u2500\u2500 design.md       # Design document\n\u251c\u2500\u2500 .github/            # GitHub workflows\n\u2502   \u2514\u2500\u2500 workflows/\n\u2502       \u2514\u2500\u2500 release.yml # CI/CD pipeline configuration\n\u251c\u2500\u2500 main.go             # Entry point for the CLI\n\u251c\u2500\u2500 go.mod              # Go module definition\n\u251c\u2500\u2500 go.sum              # Go module dependencies\n\u2514\u2500\u2500 README.md           # Project overview and installation guide\n</code></pre>"},{"location":"node-cli/#underlying-technology","title":"Underlying Technology","text":"<p>The <code>lfgnode</code> CLI is developed using the Go programming language and is designed to simplify workload and cluster management by leveraging Kubernetes technologies. Specifically, it utilizes k3s, a lightweight Kubernetes distribution optimized for edge computing, and k3d, a tool that enables running Kubernetes clusters within Docker containers.</p> <p>By integrating these technologies and Node System Backend's APIs, <code>lfgnode</code> provides an intuitive command-line interface that abstracts the complexities of Kubernetes, allowing users to efficiently manage workloads and clusters on their nodes. This approach ensures a seamless experience for deploying and maintaining applications in a containerized environment.</p>"},{"location":"workload-manager/","title":"Node System Workload Manager","text":"<p>Node system workload manager is a specific workload runs on user's node, inside the K3S cluster. It is built from Express JS with minimal codebase and dependencies. Workload manager is responsible for:</p> <ul> <li>Workload version control</li> <li>Uptime management</li> <li>Health check and reporting</li> <li>Self-update</li> <li>Sync the node system state with configuration saved in the backend</li> </ul>"},{"location":"workload-manager/#prerequisites","title":"Prerequisites","text":"<ul> <li>Your node system must be started with the <code>lfgnode start</code> command.</li> <li>Node v22 or later</li> <li><code>pnpm</code> package manager</li> </ul>"},{"location":"workload-manager/#how-to-run","title":"How to run","text":"<ol> <li>Copy the <code>.env.example</code> file to <code>.env</code> and fill in the required environment variables.</li> <li><code>NODE_SYSTEM_ENDPOINT</code>: The endpoint of the node system backend.</li> <li><code>NODE_PRIVATE_KEY</code>: The private key generated by the node CLI. You can find it at <code>~/.config/lfgnode/config.yaml</code>.</li> <li><code>SENTRY_DSN</code>: The Sentry DSN for error tracking.</li> <li>Install the dependencies:    <pre><code>pnpm install\n</code></pre></li> <li>Run the workload manager:    <pre><code>pnpm dev\n</code></pre></li> </ol> <p>Note that you are running the workload manager outside of the K3S cluster, just for debugging and developing. The actual manager is automatically deployed inside the K3S cluster when you run the <code>lfgnode start</code> command. </p>"},{"location":"workload-manager/#workflows","title":"Workflows","text":"<pre><code>sequenceDiagram\n    participant Workload\n    participant WM as Workload Manager\n    participant K3S as K3S Cluster\n    participant Backend as Node System Backend\n\n    par \n        loop Every 5-10 seconds\n            Workload-&gt;&gt;WM: Send health status\n        end\n\n        loop Every minute\n            WM-&gt;&gt;Backend: Report node health with all workload status\n        end\n    end\n\n    loop Every 10 minutes\n        WM-&gt;&gt;Backend: Fetch latest workloads and their versions\n        Backend--&gt;&gt;WM: Return workload versions\n\n        WM-&gt;&gt;K3S: List current deployments\n        K3S--&gt;&gt;WM: Return deployment list\n\n        loop For each deployment\n            alt Deployment exists but workload not found\n                WM-&gt;&gt;K3S: Delete deployment\n            else\n                WM-&gt;&gt;Backend: Fetch new deployment manifest\n                Backend--&gt;&gt;WM: Return manifest\n\n                alt Deployment exists and workload is outdated\n                    WM-&gt;&gt;K3S: Patch deployment with new manifest\n                    WM-&gt;&gt;Backend: Update workload version\n                else Deployment does not exist\n                    WM-&gt;&gt;K3S: Create new deployment\n                end\n            end\n        end\n    end\n\n    loop Self-update\n        WM-&gt;&gt;AWS S3: Get latest version in file\n        AWS S3--&gt;&gt;WM: Return latest version\n\n        WM-&gt;&gt;K3S: Get current workload manager deployment\n        K3S--&gt;&gt;WM: Return current deployment\n        alt Current version is outdated\n            WM-&gt;&gt;K3S: Patch deployment with new image\n        end\n    end</code></pre>"}]}